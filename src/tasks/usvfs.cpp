#include "pch.h"
#include "tasks.h"

// note that usvfs is the only project that has to be built for both 32- and
// 64-bit architectures
//
// prebuilts are typically only used when building on appveyor, so they reuse
// whatever was last built with contiguous integration
//
// the files generated by CI are called "artifacts", they can be seen on
// https://ci.appveyor.com/project/ModOrganizer2/usvfs, by clicking on a
// platform at the bottom, then the "Artifacts" tab

namespace mob::tasks {

    usvfs::usvfs() : basic_task("usvfs") {}

    std::string usvfs::version()
    {
        return conf().version().get("usvfs");
    }

    bool usvfs::prebuilt()
    {
        return false;
    }

    fs::path usvfs::source_path()
    {
        return conf().path().build() / "usvfs";
    }

    void usvfs::do_clean(clean c)
    {
        // delete the whole directory
        if (is_set(c, clean::reclone)) {
            git_wrap::delete_directory(cx(), source_path());

            // nothing more to do
            return;
        }

        if (is_set(c, clean::reconfigure)) {
            run_tool(create_cmake_tool(arch::x64));
            run_tool(create_cmake_tool(arch::x86));
        }

        if (is_set(c, clean::rebuild)) {
            // msbuild clean
            run_tool(create_msbuild_tool(arch::x86, msbuild::clean,
                                         task_conf().configuration()));
            run_tool(create_msbuild_tool(arch::x64, msbuild::clean,
                                         task_conf().configuration()));
        }
    }

    void usvfs::do_fetch()
    {
        fetch_from_source();
    }

    void usvfs::do_build_and_install()
    {
        build_and_install_from_source();
    }

    void usvfs::fetch_from_source()
    {
        run_tool(make_git()
                     .url(make_git_url(task_conf().mo_org(), "usvfs"))
                     .branch(version())
                     .root(source_path()));
    }

    void usvfs::build_and_install_from_source()
    {
        run_tool(create_cmake_tool(arch::x64));
        run_tool(create_cmake_tool(arch::x86));
        run_tool(create_msbuild_tool(arch::x64));
        run_tool(create_msbuild_tool(arch::x86));
    }

    cmake usvfs::create_cmake_tool(arch a, cmake::ops o) const
    {
        return std::move(
            cmake(o)
                .root(source_path())
                .def("CMAKE_INSTALL_PREFIX:PATH", conf().path().install())
                .generator(cmake::vs)
                .preset(a == arch::x64 ? "vs2022-windows-x64" : "vs2022-windows-x86")
                .arg("-DBUILD_TESTING=OFF"));
    }

    msbuild usvfs::create_msbuild_tool(arch a, msbuild::ops o, config c) const
    {
        const std::string vsbuild = (a == arch::x64 ? "vsbuild64" : "vsbuild32");
        return std::move(msbuild(o).architecture(a).configuration(c).solution(
            source_path() / vsbuild / "usvfs.sln"));
    }

}  // namespace mob::tasks
